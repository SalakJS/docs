{"./":{"url":"./","title":"Salak简介","keywords":"","body":"Salak Salak 是一个基于 koa 2.0 开发的应用框架，主要目的是为了降低日常的开发成本以及维护成本。 为什么要开发Salak 每次写接口，需要梳理文档 需要去定义路由配置，存在着一定的开发成本 团队成员开发习惯不同，造成沟通成本、维护成本增高 特性 自动生成文档 路由自动装载 数据 Joi 校验 基于模块开发 增强型中间件 文档示例 "},"intro/":{"url":"intro/","title":"快速入门","keywords":"","body":"快速入门 本篇将一步步搭建一个salak应用，让你对salak有一个初步的了解 环境准备 操作系统：支持Mac、Linux以及Windows 运行环境：node > 7.6 脚手架快速搭建 为了快速搭建项目，开发了脚手架salak-cli 安装脚手架 $ npm install -g salak-cli 创建项目 以simple模板为例 $ salak-init simple demo 安装依赖并启动 $ cd demo $ npm install $ npm start 至此，项目就可以跑起来了。 接下来，我们不使用脚手架，一步一步搭建项目： 初始化项目 $ mkdir salak-example $ cd salak-example $ npm init $ npm i --save salak 编写主入口文件 创建index.js $ vi index.js $ mkdir application const Salak = require('salak') const app = new Salak({ baseDir: __dirname, opts: { root: 'application' } }) app.listen(3000) 配置文件 $ mkdir application/config $ cd application/config $ vi default.js module.exports = { swagger: { spec: { info: { title: 'Example', description: 'description for example', version: '1.0.0' } } } } 编写控制器 $ cd .. $ mkdir controller $ cd controller $ vi test.js const { Controller, Joi } = require('salak') class Test extends Controller { static behaviors () { return { rules: { index: { meta: { summary: '测试接口', description: '第一个应用接口' }, validate: { query: { id: Joi.number().description('标示') } } } } } } actionIndex () { this.sendJson(0, 'ok', { id: this.query.id || 'unknow' }) } } module.exports = Test 启动服务 $ cd ../.. $ node index 可以访问 http://localhost:3000/test 看到具体的数据 如果访问 http://localhost:3000/test?id=error 将会显示具体的错误信息 文档访问 http://localhost:3000/api-docs 可以看到具体的接口详情 "},"basics/":{"url":"basics/","title":"基础功能","keywords":"","body":"基础功能 本章节主要介绍Salak自带的基础功能。 "},"basics/structure.html":{"url":"basics/structure.html","title":"目录结构","keywords":"","body":"目录结构 在【快速入门】章节中，对salak有了初步的了解，接下来看下基本的目录规范。 在salak中，有两种模式，单模块模式、多模块模式，通过配置文件来指定。 首先来看下多模块模式，目录如下： ├── common │ ├── config │ │ └── default.js │ ├── middleware (可选) │ ├── helper (可选) │ ├── service (可选) │ └── view (可选) ├── ${module} │ ├── config │ │ └── default.js │ ├── controller │ ├── middleware (可选) │ ├── view (可选) │ └── service (可选) ├── index.js ├── bin │ └── www ├── package.json ├── test ├── logs └── public (可选) 由框架约定的目录: public: 静态资源目录 bin/www: 可执行文件 logs: 应用日志存放目录 comon: 通用目录，存放公共的文件 common/config/${env}.js: 用于编写配置文件 common/middleware: 用于存放中间件 common/helper/index.js: 工具类，仅可以出现在公共模块 common/view: 用于公共的视图 common/service: 用于存放公共的业务逻辑 ${module}: 功能模块 ${module}/config/${env}.js: 用于存放功能模块的配置 ${module}/controller: 控制器，用于处理用户请求 ${module}/middleware: 模块中间件 ${module}/view: 模块视图 ${module}/service: 模块业务逻辑 再来看下单模块模式，与多模块不同的是，通用模块与功能模块为同一模块, 目录如下： ├── application │ ├── config │ │ └── default.js │ ├── controller │ ├── middleware (可选) │ ├── helper (可选) │ ├── view (可选) │ └── service (可选) ├── bin │ └── www ├── index.js ├── package.json ├── test └── public (可选) 由框架约定的目录: public: 静态资源目录 application: 应用模块目录 application/config/${env}.js: 用于存放配置文件 application/controller: 控制器，用于处理用户请求 application/middleware: 中间件 application/helper/index.js: 工具类 application/view: 视图存放目录 application/service: 模块业务逻辑 具体使用，在接下来的章节会进一步讲解。 "},"basics/objects.html":{"url":"basics/objects.html","title":"内置对象","keywords":"","body":"内置对象 Salak Salak，基于Koa，在一个应用中，只会被实例化一次 实例获取方式 在中间件中，第二个参数就是app实例，应用会自动加载进去 如： module.exports = (options, app) => {} 在Service，Controller中，可以通过this.app可以访问到 实例对象 BaseContext logger root configs loader BaseContext Salak Context基类 Service 业务逻辑基类 Controller 控制器 RestController restful 形式 控制器 Joi refer: https://github.com/hapijs/joi makeOutputSchema (data) type: Function @return: Joi object 配合output插件使用，用于便捷校验响应数据 "},"basics/config.html":{"url":"basics/config.html","title":"配置","keywords":"","body":"配置 框架提供了强大且可扩展的配置功能，会自动合并功能模块、通用模块以及框架的配置，按顺序覆盖，且可以根据环境维护不同的配置。 配置文件存放在各自模块的config目录中。 多环境配置 框架支持根据环境来加载配置，定义多个环境的文件，如下： config ├── default.js ├── production.js ├── development.js └── test.js 配置写法 配置文件返回Object，可以覆盖框架默认的配置，也可以定义自己的配置。 const path = require('path') module.exports = { logger: { root: path.join('/tmp', 'logs') // 修改默认日志存放地址 } } 配置加载顺序 以development环境为例： -> 公共模块默认配置 default.js -> 公共模块环境配置 development.js -> 功能模块默认配置 default.js -> 功能模块环境配置 development 配置使用规则 后面的配置会覆盖前面的配置，在当前模块使用的配置，将是模块配置与通用配置合并后的配置。 通用模块常用配置字段 bootstraps type: Array(string|Object) 模块配置入口，用于定义功能模块，存在该字段说明为多模块模式，否则为单模块模式 const path = require('path') module.exports = { bootstraps: [ 'frontend', { backend: path.join(__dirname, 'backend') } ] } routes 路由配置，提供了prefix, defaultRoute, defaultMethod字段，在功能模块中，该字段还提供了alias字段，用于设置模块在路由中的别名。 如： 功能模块: module.exports = { routes: { prefix: '/api', // 路由前缀 alias: 'blog', // 注册路由时用alias代替module名字 defaultRoute: 'post/show', // 标示Post控制器下actionShow方法进行处理 defaultMethod: ['GET'] // 默认是GET请求 } } 公共模块： module.exports = { routes: { prefix: '/api', defaultRoute: 'blog/post', // 等同于blog/post/index 标示blog模块下post控制器中的actionIndex defaultMethod: 'GET' } } logger 日志配置 swagger 文档设置 中间件配置 在相应的config中添加中间件对应的options 对于内置的中间件设置，可以修改对应的设置 如static中间件（用于渲染静态资源）的设置： module.exports = { static: { root: '/exports/www', opts: { maxage: 3600000 // 缓存1小时 } } } "},"basics/context.html":{"url":"basics/context.html","title":"Context","keywords":"","body":"BaseContext BaseContext是Controller以及Service的基类，在运行过程中进行实例化，并且会把koa ctx, next注入到实例中，同时提供了很多使用方法。 在实际开发过程中，一般不直接使用BaseContext。不过，在一些中间件开发中，可能会为了提供更简便的功能而对BaseContext注入一些方法。 接下来，我们就来看下BaseContext提供了哪些实用的函数以及对象。 constructor (context, next, module) context: Object，koa请求过程的ctx next: Function，koa请求过程的next module: string，调用的模块 config (key, module) 获取配置信息 key: string，配置key module: string, 默认为当前模块 service (key, module) 获取service实例 key: string，service名称 module: string, service所在的模块，默认查询当前模块 query, body type: Object 用于获取当前response中query、body相关数据 helper type: Object 用于获取应用的工具类 其他公有属性 module: 调用的模块 ctx: 当前请求的ctx next: 当前请求的next app: 应用app实例 logger: 日志 "},"basics/controller.html":{"url":"basics/controller.html","title":"Controller","keywords":"","body":"Controller 控制器，继承自Context，用于处理用户的请求，然后返回相应的结果。 控制器会自动校验数据，会根据规则自动注册路由。 比较推荐的做法是，在Controller编写对应的校验规则，然后调用相应的Service处理业务逻辑，最后输出结果。 如何编写Controller 所有的Controller文件必须存放在功能模块的controller目录下，支持多级目录，访问的时候通过相应的目录层级来访问。 框架默认提供了Controller基类，我们先来看下除了Context属性和方法之外，还提供了哪些方法。 Controller middleware (name, module, options) 中间件调用，只允许出现在constructor中，用于在进入action之前，执行相应的的中间件 name: 中间件名称 module: 可选，中间件所在的模块，默认为当前模块，也就是默认会加载当前模块的中间件 options: 可选， 配置，会往上回溯合并配置：options => module config => common config 在执行过程中，如果查询不到中间件，会查询框架自带的中间件。 @return {Object} Middleware实例: 提供了only和except两个方法 only (action): 只允许哪些函数可以执行中间件 except (action): 表示除了哪些action之外执行中间件 action: type: string|Array 执行的action this.middleware('test') // 表示所有方法都会执行test中间件 this.middleware('auth').except('logout') // 表示actionLogout方法不执行auth中间件 this.middleware(['cors', 'error']).only('index') // 表示只有actionIndex方法执行cors中间件和error中间件 behaviors () 静态方法，可选，用于定义路由规则以及校验规则，需要返回一个对象，包含两个字段routes、rules。 建议定义，特别是rules字段，用于自动输出文档。 routes: type: Object rules: type: Object 示例： static behaviors () { return { routes: { 'GET /unknow': 'index' // 表示将actionIndex注册为/unknow，method为GET的路由 }, rules: { index: { meta: { // 接口信息 summary: '', // 接口概要 description: '', // 接口描述 tags: ['Test'] // 接口类别 }, validate: { // 接口校验规则，包含query，params，body, formData，header，responses query: { id: Joi.number().required() // 表示query参数id必须为数字，并且必须提供 }, responses: { 200: { body: { // 表示校验状态码为200是的body体 code: Joi.number().required() }, headers: { // 表示校验状态码为200是的header } } } } } } } } sendJson (code, msg, data) 快捷输出方法，输出json code: 接口状态，一般0表示成功 msg: 接口描述 data: 接口数据 send (status, body) 接口输出 status: http状态码 body: 接口数据 render (name, variables, module) Async Function，必须打开view中间件 视图渲染 name: 视图名称 variables: 视图变量 module: 模块，视图所在模块，默认为当前模块 action定义 格式为：actionXxx，xxx为默认注册到路由上的地址 比如： /frontend/controller/blog/post.js 中的actionIndex，默认注册到的路由为/frontend/blog/post /frontend/controller/blog/post.js 中的actionShow，默认注册到的路由为/frontend/blog/post/show action参数，会自动将ctx.params绑定上。 如： async actionIndex (id, user) { // 会注册成 /:id/:user // do something } 除了Controller之外，框架还提供了RestController，扩展自Controller。 RestController 内部自定义了Restful映射关系，一般用在Restful接口上。 映射关系表： Action Http index GET / create POST / show GET /:id replace PUT /:id update PATCH /:id destroy DELETE /:id 示例 以/blog/post.js为例，如下 const { Controller, Joi } = require('salak') class Post extends Controller { constructor (...args) { super(...args) this.middleware('auth').only('index') } static behaviors () { return { routes: { // 可选，默认只会注册GET请求 'POST /:id': 'index', 'GET /:id': 'index' }, rules: { index: { meta: { summary: '文章详情' description: '获取文章详情', meta: ['Blog'] }, validate: { params: { id: Joi.number().required() } } } } } } async actionIndex (id) { const post = await this.service('post').findPost(id) this.sendJson(0, 'ok', post) } } module.exports = Post "},"basics/service.html":{"url":"basics/service.html","title":"Service","keywords":"","body":"Service Service, 继承自Context，在调用过程中实例化。 一般来说，Service用来封装业务逻辑，主要有以下几点好处： 保持Controller中逻辑简洁 保证业务逻辑独立性，抽离出来的Service能够被多个地方复用 代码解耦，提高代码可维护性 使用场景 第三方服务调用，比如发邮件、发送提醒之类的 数据处理，比如从数据库获取数据之后，再进行一些处理 使用示例 const { Service } = require('salak') class Post extends Service { async findPost (id) { const post = await this.model('post').findById(id) // 这里的this.model可以使用salak-mongo插件来注入 return post } } module.exports = Post 注意 Service文件必须存放在模块的service目录中 Service必须为Class，并且需要继承salak.Service 一个Service文件只能存在一个Service类 "},"basics/helper.html":{"url":"basics/helper.html","title":"Helper","keywords":"","body":"Helper Helper 用来提供一些实用的工具类函数，避免一些通用的逻辑分散到各处。 存放在公共模块/helper/index.js文件中，返回一个对象 定义Helper const helper = {} // 自动补全0 helper.zeroPadding = (num) => { if (num 使用Helper helper默认会被挂在在app.helper上，在Context上提供了便捷方式可以访问到，如： this.helper.zeroPadding(9) "},"basics/middleware.html":{"url":"basics/middleware.html","title":"中间件","keywords":"","body":"中间件 Salak是基于Koa 2.0开发，所以Salak的中间件形式与Koa中间件一致。 编写中间件 写法 module.exports = (options, app) => { // do something } 如果没有返回 async function，那么该中间只会在初始化时调用一次，否则会加入到中间件执行队列中。 那么，这就可以用中间件的方式来做一些初始化的工作，如数据库连接。 接下来，我们以写简单的error中间件为例： module.exports = (options, app) => { options = Object.assign({}, { status: 500 }, options) return async (ctx, next) => { try { await next() if (ctx.status === 404 && !ctx.response.body) { ctx.throw(404) } } catch (err) { app.logger.error(err) ctx.status = err.status || options.status ctx.body = err.message } } } 使用中间件 模块配置中使用 通过配置middleware字段，中间件配置通过配置对应的key即可 middleware配置有两种写法： 直接写中间件对应文件的名字，如error.js: module.exports = { middleware: [ 'error' ], error: { status: 500 } } 写中间件名字，以及中间对应的位置，如： module.exports = { middleware: [ { name: 'error', package: require('path/error') } ] } 控制器构造函数中使用 this.middleware('error', this.module, { status: 503 }) 中间件查询原则 在模块配置中，功能模块中间件 =》公共模块中间件 =》框架内建中间件 在控制器中，指定模块中间件，查询不到，会查询框架内建中间件 通用配置 无论是在模块中加载，还是在控制器加载的中间件，都支持如下配置： enable: 中间件是否开启，默认为true 框架默认中间件 框架自带中间件默认执行顺序： output static bodyparser cors jsonp error view swagger output 单次调用，用于定义app.output，控制输出json的默认字段。 可以通过修改如下配置修改默认字段名： code: 输出接口状态 msg: 输出接口信息 data: 输出接口数据 details: 错误相关 static 静态资源渲染，采用koa-static 配置： root: 默认为应用public opts: 同koa-static opts bodyparser 采用了koa-bodyparser，默认支持json、form解析 配置可参考koa-bodyparser 注：koa-bodyparser已经不包含multipart/form-data解析 cors 跨域请求中间件 配置： allowMethods 允许的方法 exposeHeaders 允许暴露的响应首部 allowHeaders 允许的头部 maxAge 用于设置preflight缓存时间 credentials 是否允许cookie jsonp jsonp输出中间件，会自动包装callback view 视图中间件，基于koa-views 配置(即views opts)： extension map engineSource options error error中间件，处理应用请求过程中报错 配置: status: 状态码设置，默认为'auto'，表示根据出错状态来自动设置http响应状态码；否则为200状态码 type: 错误输出类型，可以为json或者html，无配置情况下，框架根据accept-type自动选择 template: 错误视图路径，默认为框架自带的error.ejs logIgnoreNotFound: 日志是否不记录404，默认为false，表示不忽略 swagger 单次调用，用于注册文档路由以及json所在路由 配置： apiDocs: api访问地址，默认为/api-docs json: api json访问地址，默认为/api-json html: api 渲染默认，默认采用ReDoc 替换默认中间件 在模块middleware中编写同名中间件即可。 "},"basics/logger.html":{"url":"basics/logger.html","title":"日志","keywords":"","body":"日志 日志在web开发中是必不可少的一部分，对于应用运行状态、问题排查有着很重要的作用。 目前是基于winston。 主要特性 日志分级 统一错误日志，错误日志会打印一份到默认的错误日志中 支持日志切割，可以按年、月、日切割 配置 root string，路径，日志文件存放目录 injectConsole Boolean，是否输出到stdout，默认根据是否为生产环境来判断 capture Object，http请求日志配置，会详细记录请求来源以及响应结果 enable: 是否开启，默认为true, category: 采用哪个category来保存请求日志 level: 日志记录级别，默认为auto，自动根据状态码输出到对应的日志 categories Object，格式如下： category: { type: 'dateFile', filename: 'xxx/xxx.log', dataPattern: 'YYYY-MM-DD', level: 'info' } type: dateFile，可以使用日期切割；levelFilter，根据日志级别存放 filename: 日志存放目录以及文件名 datePattern：dateFile下存在，用于切割日志 level: 日志记录级别 transport：同winston3，用于配置需要输出到远程日志服务器，配置了transport会忽略dateFile的配置 type为logLevelFilter如下： error: { type: 'levelFilter', filename: 'error/error.log', dataPattern: 'YYYY-MM-DD', level: 'error' } defaultLevel 日志默认级别，有debug, info, warn, error autoCategory Boolean，默认为true，自动创建目录，减少配置的麻烦，默认创建按日切割的目录，第一次创建存在一定的损耗，谨慎配置。 logger配置实例 const path = require('path') module.exports = { logger: { root: path.join('/tmp', 'logs'), injectConsole: true, capture: { enable: true, category: 'http', level: 'auto' }, categories: { default: { type: 'dateFile', filename: 'default/default.log', datePattern: 'YYYY-MM-DD' }, http: { type: 'dateFile', filename: 'access/access.log', datePattern: 'YYYY-MM-DD' }, user: { type: 'dateFile', filename: 'user/user.log', datePattern: 'YYYY-MM', level: 'error' }, error: { type: 'levelFilter', filename: 'error/error.log', datePattern: 'YYYY-MM-DD' level: 'error' } }, autoCategory: true, defaultLevel: 'info' } } 使用 logger挂载在app实例上，可以直接通过app.logger直接访问。 在Context上，可以通过this.logger访问 app.logger 默认挂载了['debug', 'info', 'warn', 'error']这些方法，他们会输出到default category上。 如果需要访问对应category，只需要在app.logger上调用相应的category。 示例如下： app.logger.error('error!!') app.logger.user.info('find the user') "},"basics/docs.html":{"url":"basics/docs.html","title":"文档","keywords":"","body":"文档 介绍 框架采用Swagger 2.0，配合Joi校验规则来生成文档。 swagger配置只能出现在公共模块中。 我们先来看一个示例配置： module.exports = { swagger: { enable: true, spec: { info: { title: 'API', description: 'For api.', version: '1.0.0' }, tags: [ { name: 'Demo', description: 'For demo.' } ] } } } 配置 enable: 是否开启swagger文档 spec: swagger 选项 spec.info: Object, 必须，需要提供至少title，description，version字段，还可以提供contact、license字段，同Swagger info字段 spec.host: string，可选，文档host地址 spec.tags: Array，可选，item必须包含name和description字段 "},"advanced/":{"url":"advanced/","title":"进阶功能","keywords":"","body":"进阶功能 本章节主要从代码风格，扩展来编写。 "},"advanced/styles.html":{"url":"advanced/styles.html","title":"代码风格指南","keywords":"","body":"代码风格指南 推荐Standard风格，配合eslint做代码检查 "}}